* Current Status
This stores all my customizations for emacs that would be in the
.emacs file.

Everything seems to be working right now!
* GUI Changes
#+BEGIN_SRC emacs-lisp
(if (string= system-type "gnu/linux")
    (set-face-attribute 'default nil :height 90)) ;; change font size
(setq inhibit-startup-message t)
(tool-bar-mode -1)
(column-number-mode 1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
(show-paren-mode 1)
(display-time-mode -1)
#+END_SRC

* Themes
** Atom One Dark Theme
#+BEGIN_SRC emacs-lisp
(use-package atom-one-dark-theme
  :ensure t)
#+END_SRC

** Theme Changes
 #+BEGIN_SRC emacs-lisp
(defun matiash-toggle-dark-mode ()
  "Toggles ATOM-ONE-DARK custom theme. Assumes theme is
installed"
  (interactive)
  (if (custom-theme-enabled-p 'atom-one-dark)
      (disable-theme 'atom-one-dark)
    (enable-theme 'atom-one-dark)))
(global-set-key (kbd "<f10>") 'matiash-toggle-dark-mode)

;; Runs this hack when running macOS to start up with no selected theme.
(if (string= system-type "darwin")
    (progn
      (enable-theme 'atom-one-dark)
      (disable-theme 'atom-one-dark)))
 #+END_SRC
 
** Adwaita
Enable the Adwaita Theme. I recently started using it and really enjoy
it!
#+BEGIN_SRC emacs-lisp
(load-theme 'adwaita)
#+END_SRC

* Try
Handy package that lets you try out packages
#+BEGIN_SRC emacs-lisp
(use-package try
  :ensure t)
#+END_SRC

* Navigation
** Avy
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  :bind (("s-h" . 'avy-goto-char-timer))
  :config
  (setq avy-all-windows nil)
  (setq avy-single-candidate-jump nil))
#+END_SRC
** Ace Window
Removes the need to call other-window multiples times
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :bind ("`" . 'ace-window)
  :config
  (ace-window-display-mode)
  (setq aw-scope 'frame))
#+END_SRC

** Using Registers
*** Quick-save Point to Register + Cycle Registers
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-r") 'point-to-register)
(global-set-key (kbd "M-j") 'register-to-point)

(defun matiash-cycle-point-across-registers ()
  "Cycle point across all unique saved registers, filtering out
those that don't save a point as a marker value."
  (interactive)
  (let ((valid-marker-list (seq-uniq
			    (seq-filter (lambda (marker) (markerp marker))
					(seq-map (lambda (reg) (cdr reg)) register-alist))))
	(valid-marker-list-copy)
	(current-marker))
    (setq valid-marker-list-copy valid-marker-list)
    (while (and (setq current-marker (pop valid-marker-list-copy))
		(not (equal current-marker (point-marker)))))
    (goto-char (car (or valid-marker-list-copy valid-marker-list)))))
(global-set-key (kbd "C-,") 'matiash-cycle-point-across-registers)
#+END_SRC

** Frames
Since I'm starting to use a lot of frames, changing between them
quickly is critical.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-`") 'other-frame)
#+END_SRC

** Frames++
I tried out this package called =frame-tag=, and I absolutely love it!
It maps each frame to a number so I easily navigate between
them. Putting it into the config:
#+BEGIN_SRC emacs-lisp
(use-package frame-tag
  :ensure t
  :config (frame-tag-mode 1))
#+END_SRC

** (Hs-Mode) Expand Block during Navigation
Used to expand Hs block if I'm going to a particular line in a hidden
block.
#+BEGIN_SRC emacs-lisp
(defadvice goto-line (after expand-after-goto-line
                            activate compile)
  "Runs hideshow-expand on the affected block when using
goto-line in a collapsed buffer."
  (save-excursion
    (hs-show-block)))
(defadvice register-to-point (after expand-after-goto-line
                            activate compile)
  "Runs hideshow-expand on the affected block when using
register-to-point in a collapsed buffer."
  (save-excursion
    (hs-show-block)))
#+END_SRC

** Forward Up List
I'm switching from using =backward-up-list= to moving forward up a
list cause I use that so much more often.
#+BEGIN_SRC emacs-lisp
(defun matiash-forward-up-list (&optional ARG)
  "Acts like backward-up-list, but point moves to the end of the
balanced parentheses instead of the beginning."
  (interactive "p")
  (if ARG
      (backward-up-list (- ARG) t t)
    (backward-up-list (- 1) t t)))
(global-set-key (kbd "C-M-u") 'matiash-forward-up-list)
#+END_SRC

** Switching Between Buffers
I usually end up working with two files and going back and forth
between them. Adding a keybinding to make that easier.
#+BEGIN_SRC emacs-lisp
(defun matiash-switch-to-other-buffer ()
  "Switches to the last buffer used."
  (interactive)
  (switch-to-buffer (other-buffer)))
(global-set-key (kbd "C-<tab>") 'matiash-switch-to-other-buffer)
#+END_SRC

* Modes
** Org Mode
Used to organize myself, especially for project management.
*** Org Mode Customizations
#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '())
(setq org-agenda-sorting-strategy
      '((agenda habit-down time-up priority-down category-keep)
	(todo priority-down todo-state-down)
	(tags priority-down category-keep)
	(search category-keep)))
(setq org-clock-mode-line-total 'today)
(setq org-log-into-drawer t)
(setq org-log-note-headings
      '((done . "CLOSING NOTE %t")
	(state . "%-12s %t")
	(note . "Note taken on %t")
	(reschedule . "Rescheduled from %S on %t")
	(delschedule . "Not scheduled, was %S on %t")
	(redeadline . "New deadline from %S on %t")
	(deldeadline . "Removed deadline, was %S on %t")
	(refile . "Refiled on %t")
	(clock-out . "")))
(setq org-src-window-setup 'current-window)
#+END_SRC

*** Key shorcuts
 #+BEGIN_SRC emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cb" 'org-switchb)
 #+END_SRC

*** Export settings
#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(unless (boundp 'org-latex-classes)
  (setq org-latex-classes nil))
(add-to-list 'org-latex-classes
             '("article"
               "\\documentclass{article}"
               ("\\section{%s}" . "\\section*{%s}")))
(setq org-latex-listings 'minted)
(add-to-list 'org-latex-packages-alist '("" "minted"))
(add-to-list 'org-latex-packages-alist '("dvipsnames" "xcolor"))
(add-to-list 'org-latex-packages-alist '("" "setspace"))

(setq org-latex-pdf-process
      '("pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex --shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

*** Code Block Execution
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (C . t)
     (shell .t)))
  )

(setq org-src-fontify-natively t
    org-src-preserve-indentation t
    org-src-tab-acts-natively t
    org-confirm-babel-evaluate nil)
#+END_SRC

*** Org Capture Templates
Used to capture ideas and things to do. Right now I'm in the middle of
implementing a workflow, so this will be edited soon enough.
#+BEGIN_SRC emacs-lisp
(defun matiash-get-entry-format () ""
       (format "%-13s" "\"TODO\""))
(setq org-capture-templates
      '(("p" "Personal Journal" entry (file+datetree personal-journal-path)
	 "* [%<%I:%M%p>] %?\n\n")
        ("e" "Entry" entry (file+headline inbox-path "Inbox")
         "* TODO %?\n:LOGBOOK:\n- %(matiash-get-entry-format)%U\n:END:\n")
        ("w" "Work Note" entry (file+headline work-inbox-path "Inbox") "* TODO %?")))
#+END_SRC

*** Org Journal Workflow
These customizations are used to implement the workflow of using
journal Org files to house progress and todo's on projects.
#+BEGIN_SRC emacs-lisp
(defun matiash-org-keywords ()
  "Parse the buffer and return a cons list of (property . value)
from lines like: #+PROPERTY: value"
  (org-element-map (org-element-parse-buffer 'element) 'keyword
    (lambda (keyword) (cons (org-element-property :key keyword)
                            (org-element-property :value keyword)))))
(defun matiash-org-keyword (KEYWORD)
  "Get the value of a KEYWORD in the form of #+KEYWORD: value"
  (cdr (assoc KEYWORD (matiash-org-keywords))))

(defun matiash-is-journal-file ()
  "Determines if the current file is a 'journal file'. This is an
Org file that just has a datetree with a particular format that
fits my workflow. In the journal file, I can add journal entries
that get added to the right date in the datetree with a timestamp
automatically (functions shown below). All journal files contain
the property #+JOURNAL_FILE set to t, like so: #+JOURNAL_FILE: t"
  (equal "t" (matiash-org-keyword "JOURNAL_FILE")))

(defun matiash-add-journal-entry ()
  "Assumes point is in an org buffer. Adds a journal entry with
the timestamp under the current day in the datetree, adding a
heading for the current day if necessary. Point is moved to the
right of timestamp."
  (interactive)
  (save-restriction
    (widen)                             ;in case current buffer is narrowed
    (if (not (matiash-is-journal-file))
        (error "File does not contain #+JOURNAL_FILE set to t")
      (funcall #'org-datetree-find-date-create
	       (calendar-gregorian-from-absolute (org-today)))
      (org-narrow-to-subtree)
      (end-of-buffer)
      (org-return)                          ;addresses one line heading
      (delete-blank-lines)                  ;that gets cut otherwise
      (org-insert-heading 4 t)              ;t to move after prev heading
      (insert (format-time-string "[%I:%M%p] " (current-time)))
      (message "Done"))))

(defun matiash-add-todo-entry ()
  "Assumes point is in an org buffer. Adds a todo entry with a
logbook drawer including the time the todo entry was
created. Adds the heading under the current day in the
datetree,creating a heading for the current day if
necessary. Point is set to right after TODO entry."
  (interactive)
  (save-restriction
    (widen)                             ;in case current buffer is narrowed
    (if (not (matiash-is-journal-file))
        (error "File does not contain #+JOURNAL_FILE set to t")
      (funcall #'org-datetree-find-date-create
	       (calendar-gregorian-from-absolute (org-today)))
      (org-narrow-to-subtree)
      (end-of-buffer)
      (org-return)                          ;addresses one line heading
      (delete-blank-lines)                  ;that gets cut otherwise
      (org-insert-heading 4 t)              ;t to move after prev heading
      (insert (format "TODO \n    :LOGBOOK:\n   - %s%s\n   :END:\n"
		      (matiash-get-entry-format)
		      (format-time-string
		       (org-time-stamp-format (current-time) t)
		       (current-time))))
      (end-of-buffer)
      (org-previous-visible-heading 1)
      (org-cycle)
      (org-end-of-line)
      (message "Done"))))
#+END_SRC

*** Org Clocking
Useful to see how much time I'm spending on a project
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c C-x TAB") 'org-clock-in)
(global-set-key (kbd "C-c C-x C-o") 'org-clock-out)
#+END_SRC

*** Org TODO Keywords
Works with workflow system I'm implementing.
#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t!)" "WAITING(a@)" "NEXT(n!)" "WORKING(w!)" "|" "DONE(d!)" "CANCELLED(c@)")
	(sequence "NOTE(o)")))
(setq org-todo-keyword-faces
      '(("ENTRY" . "brown")
        ("TODO" . org-warning)
        ("NOTE" . "purple")
        ("NEXT" . "blue")
        ("WORKING" . "black")
        ("WAITING" . "orange")
        ("CANCELLED" . org-warning)))
#+END_SRC

*** Org TODO Refiling
Working with implemented workflow to refile a TODO from inbox to an
open org buffer and move it to the current day in the datetree.
#+BEGIN_SRC emacs-lisp
(defun +org/opened-buffer-files ()
  "Return the list of files currently opened in emacs"
  (interactive)
  (delq nil
        (mapcar (lambda (x)
                  (if (and (buffer-file-name x)
                           (string-match "\\.org$"
                                         (buffer-file-name x)))
                      (buffer-file-name x)))
                (buffer-list))))

(defun matiash-move-subtree-to-current-day ()
  ""
  (org-cycle)
  (org-copy-subtree 1 t)
  (funcall #'org-datetree-find-date-create
	   ;; Current date, possibly corrected for late night
	   ;; workers.
	   (calendar-gregorian-from-absolute (org-today)))
  (org-narrow-to-subtree)
  (end-of-buffer)
  (org-return)                          ;addresses one line heading
  (delete-blank-lines)                  ;that gets cut otherwise
  (org-paste-subtree 4)
  (widen))
#+END_SRC

*** Org Agenda View Customizations
I ended up creating an agenda view that shows the current day todos
plus unscheduled ones. Skip function found at [[https://github.com/mwfogleman/.emacs.d/blob/master/michael.org][this guy's emacs config]].
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(("d" "Day Agenda with Current-day and Unscheduled TODOs"
	 ((agenda #1="" ((org-agenda-span 1)
			 (org-agenda-skip-function
			  '(org-agenda-skip-entry-if 'todo
						     '("DONE"
						       "CANCELLED"
						       "NOTE")))))
	  (todo #1# ((org-agenda-overriding-header "\nUnscheduled TODO")
                     (org-agenda-skip-function
		      '(org-agenda-skip-entry-if 'scheduled 'todo
						 '("DONE"
						   "CANCELLED"
						   "NOTE")))))))
	("b" "Buffer summary"
	 ((todo "" ((org-agenda-files `(,inbox-path))))))
        ("w" "Buffer summary"
	 ((todo "" ((org-agenda-files `(,work-inbox-path))))))))
#+END_SRC

*** Org Journal Default Visibility
Used to see journals from workflow better, showing every day entry in
the datetree by default.
#+BEGIN_SRC emacs-lisp
(defun load-journal-visibility ()
  ""
  (if (matiash-is-journal-file)
      (org-shifttab 3)
    nil))
#+END_SRC

*** Org Workflow Variables
#+BEGIN_SRC emacs-lisp
(setq org-refile-targets '((+org/opened-buffer-files :level . 0)))
(setq org-refile-use-outline-path 'file)
(add-hook 'org-after-refile-insert-hook 'matiash-move-subtree-to-current-day)
(add-hook 'org-mode-hook 'load-journal-visibility)
(setq org-agenda-window-setup 'current-window)
#+END_SRC

*** Org Workflow Shortcuts
**** Jump to Inbox
This function makes use of a hardcoded file name - put this in a
variable instead.
#+BEGIN_SRC emacs-lisp
(defun matiash-jump-to-inbox ()
  "Jump to the agenda view for inbox, where Org captured events
get stored."
  (interactive)
  (org-agenda nil "b"))
(global-set-key (kbd "s-p") 'matiash-jump-to-inbox)
(defun matiash-jump-to-work-inbox ()
  "Jump to the agenda view for work inbox, where Org captured
events get stored."
  (interactive)
  (org-agenda nil "w"))
(global-set-key (kbd "s-i") 'matiash-jump-to-work-inbox)
#+END_SRC

**** Jump to Org Agenda + TODO
#+BEGIN_SRC emacs-lisp
(defun matiash-activate-agenda-todo ()
  "Jump to org agenda and todo interactive system"
  (interactive)
  (org-agenda nil "d" 'buffer))
(global-set-key (kbd "s-a") 'matiash-activate-agenda-todo)
#+END_SRC

**** Create a journal entry
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-j") 'matiash-add-journal-entry)
#+END_SRC

**** Create a todo entry
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-t") 'matiash-add-todo-entry)
#+END_SRC

*** Remove Agenda Cycle Keybinding
#+BEGIN_SRC emacs-lisp
(defun matiash-unmap-agenda-cycle () ""
       (define-key org-mode-map (kbd "C-,") nil))
(add-hook 'org-mode-hook 'matiash-unmap-agenda-cycle)
#+END_SRC

*** Remap C-tab to switch between buffers
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
          (lambda ()
            (define-key org-mode-map (kbd "<C-tab>") 'matiash-switch-to-other-buffer)))
#+END_SRC

*** Refile when state changed to WORKING
I want to refile the todo item when I change its state to WORKING.

This is just for refiling a todo when I'm in a workflow journal and am
changing to the WORKING state. Note that the =org-add-log-setup= is
taken from the =org-todo= source code and assumes that I want to
record the time of state change when switching to the WORKING state.

=org-agenda-redo-all= is called to refresh the agenda to see that the
todo was changed to WORKING in the agenda view, since I usually change
the todo status in the agenda view.

#+BEGIN_SRC emacs-lisp
(defun matiash-refile-working-state ()
  "Customization to refile a task when it gets set to the WORKING
state. This allows for easier viewing of the items that were most
recently worked on. Item gets refiled to the end of the subtree
for the current day in the journal file."
  (if (and (matiash-is-journal-file)
	   (equal "WORKING" org-state))
      (progn (matiash-move-subtree-to-current-day)
	     (org-add-log-setup 'state org-state nil 'time)
	     (org-agenda-redo-all t))))
(add-hook 'org-after-todo-state-change-hook 'matiash-refile-working-state)
#+END_SRC

*** Remove Org Force Cycle Keybinding
This is done to allow for a shortcut that will switch buffers quickly.
#+BEGIN_SRC emacs-lisp
(defun matiash-unmap-org-force-cycle () ""
       (define-key org-mode-map (kbd "C-<tab>") nil))
(add-hook 'org-mode-hook 'matiash-unmap-org-force-cycle)
#+END_SRC

*** AutoFill mode when in Org Mode
Here I'll set auto fill mode on to a total of 70 characters. Makes
filling out Org files in general cleaner and easier to read.
#+BEGIN_SRC emacs-lisp
(defun matiash-set-fill-column-70 ()
  "Sets 'fill-column' to 70"
  (setq fill-column 70))
(add-hook 'org-mode-hook 'auto-fill-mode)
(add-hook 'org-mode-hook 'matiash-set-fill-column-70)
#+END_SRC

*** Flyspell Mode When in Org Mode
It helps to keep the text free from spelling mistakes.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'flyspell-mode)
#+END_SRC

*** Org Mode Face Customizations
**** Source Blocks
#+BEGIN_SRC emacs-lisp
(set-face-attribute 'org-block nil :background "pale goldenrod")
(set-face-attribute 'org-block-begin-line nil :background "gray85")
#+END_SRC

** Flycheck Mode
I have this turned off right now - I should check it out more
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t)
#+END_SRC

** Ido Mode
*** Enable
#+BEGIN_SRC emacs-lisp
(use-package ido
  :config
  (ido-mode 1)
  (setq ido-default-buffer-method 'selected-window)
  (setq ido-default-file-method 'selected-window)
  (setq ido-auto-merge-work-directories-length -1)
  (setq ido-enable-flex-matching t)
  (setq ido-everywhere t)
  (setq ido-max-prospects 5))
#+END_SRC

*** View File Ido
Make searching through buffers and finding files easier
#+BEGIN_SRC emacs-lisp
(defun matiash-view-file-ido ()
  "Runs the view-file function, but with the power of Ido."
  (interactive)
  (view-file (buffer-file-name (ido-find-file))))
(global-set-key (kbd "C-x C-r") 'matiash-view-file-ido)
#+END_SRC

** Electric Indent Mode
I'm trying to replace RET with C-j to remove some of the burden on my
right pinky, which feels the most pain when I type on Emacs for a
while. Setting this mode off allows automatic indenting whenever I
press C-j.
#+BEGIN_SRC emacs-lisp
(electric-indent-mode -1)
#+END_SRC

** Subword Mode
Excellent when I'm in Java or anything with camel case strings. Allows
for movement across subwords.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c C-w") 'subword-mode)
#+END_SRC

** View Mode
Mode to view files. I'm customizing this mode to help me efficiently
look through source code. I'm currently trying out narrowing code,
widening code, easily highlighting function definitions with ".", and
cloning code into an indirect buffer.
#+BEGIN_SRC emacs-lisp
(defun matiash-hs-mode-condition ()
  "Determines if 'hs-minor-mode' should be enabled in 'view-mode'"
  (not (or (string= major-mode "fundamental-mode")
               (string= major-mode "org-mode")
               (string= major-mode "markdown-mode")
               (string= major-mode "diff-mode")
               (string= major-mode "package-menu-mode"))))

(defun matiash-view-mode-setup ()
  "Add my preferred keybindings to make view-mode easier to navigate"
  (define-key view-mode-map (kbd "g") 'goto-line)
  (define-key view-mode-map (kbd "r") 'point-to-register)
  (define-key view-mode-map (kbd "j") 'register-to-point)
  (define-key view-mode-map (kbd "TAB") 'hs-toggle-hiding)
  (define-key view-mode-map (kbd "i") 'clone-indirect-buffer)
  (if (string= system-type "darwin")    ; For Mac only
      (progn 
        (define-key view-mode-map (kbd "<C-M-tab>") 'hs-hide-level)
        (define-key view-mode-map (kbd "<backtab>") 'hs-show-all))))
(add-hook 'view-mode-hook 'matiash-view-mode-setup)

(defun matiash-view-buffer ()
  "Enable standard 'view-mode' on the current bufer, but defining
EXIT-ACTION to be a function that turns off 'hs-minor-mode'. We
want to disable it because hs-minor-mode gets enabled upon
entering view-mode in 'matiash-view-mode-setup'."
  (interactive)
  (view-buffer (current-buffer)
               (lambda (buffer)
                 (switch-to-buffer buffer)
                 (if (matiash-hs-mode-condition)
                     (hs-minor-mode -1)))))
(global-set-key (kbd "C-x C-v") 'matiash-view-buffer)

(defun matiash-should-do-view-mode ()
  "Determines whether view-mode should be turned on"
  (if (or (string= major-mode "eshell-mode")
          (string= major-mode "shell-mode"))
      nil
    t))
(defun matiash-toggle-view-mode ()
  "Toggle View mode"
  (if view-mode
      (view-mode -1)
    (view-mode 1)))
(defun matiash-safe-view-mode ()
  "Toggles view mode unless certain mode is on"
  (interactive)
  (if (matiash-should-do-view-mode)
      (matiash-toggle-view-mode)
    (message "Cannot enable view mode for this buffer.")))
(global-set-key (kbd "s-m") 'matiash-safe-view-mode)
#+END_SRC

** Markdown Mode
I don't use Markdown a lot, but I'll need to start writing it for
work. I figured it's a handy package to have in general since most
Github README files are also written in Markdown.
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t)
#+END_SRC

** Beacon Mode
I've been trying this package out lately, and its been super useful to
have. It basically shows you the point easily.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :config
  (beacon-mode))
#+END_SRC

* Searching
** Ag
Uses the silver searcher shell program to search quickly. Good for
finding references of strings in many files.
#+BEGIN_SRC emacs-lisp
(use-package ag
  :ensure t
  :config
  (setq ag-reuse-buffers t)
  (setq ag-reuse-window t))
#+END_SRC

* Buffer Management
** Saving Buffer
Easily the most used key I use. Small tweak but huge payoff.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<menu>") 'save-buffer)
#+END_SRC

** Global Auto Revert Mode
Turning on auto revert buffer and removing the confirmation message
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
(setq auto-revert-verbose nil)
#+END_SRC

** Ibuffer
*** Shortcuts
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x C-b") 'list-buffers)
#+END_SRC

*** Customization
#+BEGIN_SRC emacs-lisp
(setq ibuffer-show-empty-filter-groups nil)
(add-hook 'ibuffer-mode-hook
	  '(lambda ()
	     (ibuffer-auto-mode 1)
	     (ibuffer-switch-to-saved-filter-groups "home")
	     (define-key ibuffer-mode-map (kbd "`") 'ace-window)))
(setq ibuffer-saved-filter-groups
      '(("home"
	 ("emacs-config" (or (filename . ".emacs.d")
			     (filename . ".emacs")))
	 ("Org" (or (mode . org-mode)
		    (filename . "OrgMode")))
         ("code" (or (mode . c++-mode)
                     (mode . c-mode)
                     (mode . python-mode)
                     (mode . java-mode)
                     (mode . latex-mode)))
	 ("Emacs Buffers" (or (name . "\*Help\*")
                              (name . "\*Apropos\*")
                              (name . "\*info\*")
                              (name . "\*scratch\*")
                              (name . "\*Messages\*")
                              (name . "\*Occur\*")
                              (name . "\**\*"))))))
(setq ibuffer-formats '((mark " " name)
                        (mark " " name)))
#+END_SRC

** Revert Buffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f5>") 'revert-buffer)
(global-set-key (kbd "s-r") 'revert-buffer)
#+END_SRC

** Delete Buffer
Quick way to delete the current buffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-k") 'kill-current-buffer)
#+END_SRC

** Switch Buffer
My pinky really gets tired of pressing the control key, and I switch
buffers really often. I'm going to test mapping to Super-b and see if
that makes any difference.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-b") 'ido-switch-buffer)
#+END_SRC

* Window Management
** Zoom into and out of window - Single Frame
This is a handy function to expand and compress a buffer momentarily
#+BEGIN_SRC emacs-lisp
(defun matiash-toggle-zoom ()
  "'Zooms' into window and out, restoring the original window
configuration for the frame."
  (interactive)
  (if (= 1 (length (window-list)))
      (jump-to-register '_)
    (progn
      (window-configuration-to-register '_)
      (delete-other-windows)
      )))
(global-set-key (kbd "C-x 5 z") 'matiash-toggle-zoom)
#+END_SRC

** Delete Window
Quick way to delete the current window
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-s-k") 'delete-window)
(global-set-key (kbd "<C-s-268632075>") 'delete-window) ;; for Mac
#+END_SRC

** Winner Mode
I'm going to check our =winner-mode= now that I'm displaying things in
side windows and I think it could be useful.
#+BEGIN_SRC emacs-lisp
(use-package winner
  :config
  (global-set-key (kbd "s-<left>") 'winner-undo)
  (global-set-key (kbd "s-<right>") 'winner-redo)
  (winner-mode))
#+END_SRC

* Frame Management
** Compile Frame
Compile the code in another frame. Handy when resolving bugs.
#+BEGIN_SRC emacs-lisp
(defun matiash-compile-mode ()
  "Create a new frame with the selected buffer alongside the compile buffer."
  (interactive)
  (select-frame (make-frame))
  (compile (compilation-read-command compile-command)))
(global-set-key (kbd "C-x 5 c") 'matiash-compile-mode)
(global-set-key (kbd "<f6>") 'matiash-compile-mode)
#+END_SRC

** GDB Frame
Run GDB on another frame. Helpful to debug.
#+BEGIN_SRC emacs-lisp
(defun matiash-gdb-mode ()
  "Create a new frame with the selected buffer alongside the compile buffer."
  (interactive)
  (select-frame (make-frame))
  (split-window-below)
  (gdb (gud-query-cmdline 'gdb)))
(global-set-key (kbd "C-x 5 d") 'matiash-gdb-mode)
(global-set-key (kbd "<f7>") 'matiash-gdb-mode)
#+END_SRC

** Ag Frame
Display silver searcher in another frame.
#+BEGIN_SRC emacs-lisp
(defun matiash-code-search-mode ()
  "Create a new frame with the selected buffer alongside the ag
search results buffer."
  (interactive)
  (select-frame (make-frame))
  (ag (ag/read-from-minibuffer "Search string") (read-directory-name "Directory: ")))
(global-set-key (kbd "C-x 5 s") 'matiash-code-search-mode)
(global-set-key (kbd "<f8>") 'matiash-code-search-mode)
#+END_SRC

** Shell Mode
Create a new frame with the shell. Figure out if you want to change
this eshell or not.
#+BEGIN_SRC emacs-lisp
(defun matiash-open-shell-mode ()
  "Create a new frame with just the shell."
  (interactive)
  (select-frame (make-frame))
  (shell)
  (delete-other-windows))
(global-set-key (kbd "C-x 5 h") 'matiash-open-shell-mode)
#+END_SRC

** Region to New Frame
Creates a function that will copy a region and put it in a new frame
on a scratch buffer.
#+BEGIN_SRC emacs-lisp
(defun matiash-copy-region-to-new-frame ()
  "Assumes a region is selected. Creates a variable size frame
with a copy of the text from the region."
  (interactive)
  (let ((original-frame (selected-frame))
        (frame (make-frame))
        (line-count (count-lines (region-beginning) (region-end)))
        (buffer (generate-new-buffer 
                 (generate-new-buffer-name "untitled"))))
    (kill-ring-save (region-beginning) (region-end))
    (select-frame frame)
    (switch-to-buffer buffer)
    (yank)
    (beginning-of-buffer)
    (fit-frame-to-buffer frame line-count line-count 80 80)
    (select-frame original-frame)))
(global-set-key (kbd "C-x 5 r") 'matiash-copy-region-to-new-frame)
(global-set-key (kbd "<f9>") 'matiash-copy-region-to-new-frame)
#+END_SRC

** Delete Frame
Quick way to delete current frame
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-s-k") 'delete-frame)
(global-set-key (kbd "M-s-Ëš") 'delete-frame) ;; for Mac
#+END_SRC

** New Frame with s-n
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-n") 'make-frame)
#+END_SRC

* Window
The window package is used to decide which window or frame to display
a buffer. Here I set the =display-buffer-alist=, which will open
buffers according to the rules I gave for different buffers.
** Helper Predicate
#+BEGIN_SRC emacs-lisp
(defun matiash-use-some-frame-predicate (frame)
  "Returns t on the first frame that does not have a visible
  buffer running shell or eshell, returning nil otherwise."
  (let ((windows (window-list frame))
        (current-window)
        (valid-frame t))
    (while windows
      (setq current-window (car windows))
      (setq windows (cdr windows))
      (with-current-buffer (window-buffer current-window)
        (if (or
             (string= major-mode "eshell-mode")
             (string= major-mode "shell-mode"))
            (setq valid-frame nil))))
    valid-frame))
#+END_SRC

** Display Buffer Alist
#+BEGIN_SRC emacs-lisp
(setq display-buffer-alist
      '(("\\*Org Src.*\\*" . (display-buffer-same-window))
        ("\\*e?shell\\*" (display-buffer-in-side-window) (side . bottom) (window-height . 0.20) (slot . 0))
        ("\\*info\\*"  (display-buffer-pop-up-frame))
        ("\\*Man.*\\*" (display-buffer-pop-up-frame))
        ("\\*monky:.*\\*" (display-buffer-same-window))
        ("\\*vc-log\\*" (display-buffer-same-window))
        ("\\*vc-.*\\*" (display-buffer-in-side-window) (side . bottom) (window-height . 0.5))
        ("\\*diff\\*" (display-buffer-in-side-window) (side . bottom) (window-height . 0.5))
        ("\\*Buffer List\\*" (display-buffer-in-side-window) (side . left) (window-width . 0.15))
        ("\\*Flycheck errors\\*" (display-buffer-in-side-window) (side . bottom) (slot . -1))
        ("\\*.*\\*" (display-buffer-in-side-window) (window-height . 0.20) (slot . 1))
        (".*" (display-buffer-use-some-window) ;; (display-buffer-use-some-frame) 
                                               ;;   (frame-predicate . matiash-use-some-frame-predicate)
         )))
#+END_SRC

** Toggle Side Windows
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "s-<menu>") 'window-toggle-side-windows)
(global-set-key (kbd "s-<f13>") 'window-toggle-side-windows) ; for Mac
#+END_SRC

** Enlarge Side Window
Make it easier to enlarge a side window if you need to read the text
more. Specific to side windows that are positioned at the bottom of
the frame.
#+BEGIN_SRC emacs-lisp
(defun matiash-enlarge-side-window ()
  "Specific only to side windows positioned at the bottom of the
  frame. Enlarges side window"
  (interactive)
  (if (< 20 (window-max-delta))
      (enlarge-window 20)
    (message "Cannot enlarge window any further.")))
(defun matiash-reduce-side-window ()
  "Specific only to side windows positioned at the bottom of the
  frame. Reduces side window"
  (interactive)
  (if (< 20 (window-min-delta))
      (enlarge-window (- 20))
    (message "Cannot enlarge window any further.")))
(global-set-key (kbd "s-=") 'matiash-enlarge-side-window)
(global-set-key (kbd "s--") 'matiash-reduce-side-window)
#+END_SRC

* Dired
Powerful package to navigate between files and perform operations on
files.
#+BEGIN_SRC emacs-lisp
(define-key dired-mode-map (kbd "j") 'ido-find-file)
(define-key dired-mode-map (kbd "l") 'dired-up-directory)
(add-hook 'dired-mode-hook 'dired-hide-details-mode)
(global-set-key (kbd "C-x C-j") 'dired-jump)
(setq dired-listing-switches "-alth")
#+END_SRC

* Coding
** C/C++
*** C++ Modern Syntax highlighting
#+BEGIN_SRC emacs-lisp
(use-package modern-cpp-font-lock
  :ensure t
  :config
  (modern-c++-font-lock-global-mode t))
#+END_SRC

*** Basic Offset
Setting that to 2, at least for my current job.
#+BEGIN_SRC emacs-lisp
(setq-default c-basic-offset 2)
#+END_SRC

** Compile
*** Shortcuts
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f6>") 'compile)
#+END_SRC

*** Compile Variables
#+BEGIN_SRC emacs-lisp
(setq compilation-always-kill t)
(setq compilation-scroll-output 'first-error)
#+END_SRC

** GDB
#+BEGIN_SRC emacs-lisp
(setq gdb-many-windows t)
#+END_SRC

* TRAMP
** Verbose
#+BEGIN_SRC emacs-lisp
(require 'tramp)
(setq tramp-verbose 1)
;; (setq tramp-verbose 6)
(setq password-cache-expiry nil)
(setq tramp-terminal-type "dumb")
#+END_SRC

* Shell
Some shell configurations.
** Setup Bash Profile Variable
Sets up bash profile. I can now call 'remote-bash using
=connection-local-set-profiles=.
#+BEGIN_SRC emacs-lisp
(connection-local-set-profile-variables
       'remote-bash
       '((explicit-shell-file-name . "/bin/bash")
         (explicit-bash-args . ("-i"))))
(connection-local-set-profiles
       '(:application tramp :protocol "sshx" :machine "devf")
       'remote-bash)
#+END_SRC

* Eshell
** Eshell Variables
#+BEGIN_SRC emacs-lisp
(setq eshell-destroy-buffer-when-process-dies t)
(setq eshell-history-size 1000000)
(setq eshell-cmpl-cycle-completions nil)
(setq eshell-cmpl-ignore-case t)
#+END_SRC

** Change the Default Eshell prompt
This gives problems when root, but that can be fixed later.
#+BEGIN_SRC emacs-lisp
(setq eshell-prompt-function
      (lambda ()
        (propertize
         (concat
          "["
          (getenv "USER")
          "@"
          (replace-regexp-in-string "\n"
                                    ""
                                    (shell-command-to-string "hostname"))
          " "
          (replace-regexp-in-string "^.*:" "" (eshell/pwd))
          "]"
          (if (= (user-uid) 0) "# " " $ "))
         'face `,(if (seq-contains custom-enabled-themes 'atom-one-dark)
                     '(:foreground "yellow")
                  '(:foreground "red")))))
#+END_SRC

** Set Pager to cat
This is done because running some commands assume a complex terminal
to run less or something.  Setting the PAGER environment variable to
cat allow for eshell to get full text.
#+BEGIN_SRC emacs-lisp
(setenv "PAGER" "cat")
#+END_SRC

** Add Exec Path From Shell
When you load Emacs independently, particularly on MacOS, the path is
not the same as when you open Emacs in a terminal. I'm importing this
package to get that path since I sometimes can't find certain
commands.
#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :config
  (exec-path-from-shell-initialize))
#+END_SRC

** Open Shell Using s-l

   I'm thinking of moving from my current workflow that centers around
   the the shell, to moving the shell to a side window. I only use the
   shell for version control, and sometimes running things, and as
   long as I have enough space, I should be fine right?
#+BEGIN_SRC emacs-lisp
(defun matiash-toggle-eshell-mode ()
  "Toggle between closing and opening eshell"
  (interactive)
  (if (string= major-mode "eshell-mode")
      (window-toggle-side-windows)
    (eshell)))
(global-set-key (kbd "s-l") 'matiash-toggle-eshell-mode)
#+END_SRC

* PDF View
Used to view PDF's
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :ensure t
  :config
  (if (not (string= system-type "darwin"))
      (pdf-tools-install)))

(use-package org-pdfview
  :ensure t)
#+END_SRC

* Cycling through Errors/Results
I use these commands a lot when cycling through code errors or search
results.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-`") 'next-error)
(global-set-key (kbd "C-M-`") 'previous-error)
#+END_SRC

* Insert / Delete Text
** Delete Sexp
Sets C-M-Backspace to remove a string expression. Note this key
usually gets caught by the underlying operating system, so be sure to
remove that shortcut before using this keybinding.
#+BEGIN_SRC emacs-lisp
(global-set-key [C-M-backspace] 'backward-kill-sexp)
#+END_SRC

** Custom Open Line (Electric Indent Mode)
#+BEGIN_SRC emacs-lisp
(defun matiash-open-line()
  "Aims to create a new line below point yet keep point
indented."
  (interactive)
  (save-excursion 
    (electric-newline-and-maybe-indent)))
(global-set-key (kbd "C-o") 'matiash-open-line)
#+END_SRC

** Insert Balanced Chars
Really helpful when writing in a programming language, but also just
writing strings in general.
#+BEGIN_SRC emacs-lisp
(defun matiash-insert-braces (&optional arg)
  "Insert pair of balanced braces. Places point between them."
  (interactive "P")
  (insert-pair arg ?\{ ?\}))
(global-set-key (kbd "C-{") 'matiash-insert-braces)

(defun matiash-insert-brackets (&optional arg)
  "Insert pair of balanced brackets. Places point between them."
  (interactive "P")
  (insert-pair arg ?\[ ?\]))
(global-set-key (kbd "M-[") 'matiash-insert-brackets)

(defun matiash-insert-quotes (&optional arg)
  "Insert pair of balanced quotes. Places point between them."
  (interactive "P")
  (insert-pair arg ?\" ?\"))
(global-set-key (kbd "M-\"") 'matiash-insert-quotes)

(defun matiash-insert-single-quotes (&optional arg)
  "Insert pair of balanced single quotes. Places point between
them."
  (interactive "P")
  (insert-pair arg ?\' ?\'))
(global-set-key (kbd "M-\'") 'matiash-insert-single-quotes)

(defun matiash-insert-balanced-equals (&optional arg)
  "Insert pair of balanced equals signs. Places point between
them."
  (interactive "P")
  (insert-pair arg ?\= ?\=))
(global-set-key (kbd "C-=") 'matiash-insert-balanced-equals)
#+END_SRC

** Balanced Chars Remove Extra Space
Usually I can add the space myself after inserting a pair of balanced
chars, so let's turn this off.
#+BEGIN_SRC emacs-lisp
(setq parens-require-spaces nil)
#+END_SRC

** Change Undo keybinding
This one is going to be hard to get used to, but I just hope I don't
undo that much.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-/") 'undo)
#+END_SRC

* Web
** Firefox
This is my main browser, so I'll make it such:
#+BEGIN_SRC emacs-lisp
(setq browse-url-generic-program "firefox")
#+END_SRC

** URLs
*** Browsing URLs
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c u") 'browse-url-at-point)   
#+END_SRC

*** Goto Address Mode
This mode is very handy since it highlights links. Sometimes link
appear in shell output or in version control logs, so I'll enable that
mode in those places.
#+BEGIN_SRC emacs-lisp
(add-hook 'shell-mode-hook 'goto-address-mode)
(add-hook 'eshell-mode-hook 'goto-address-mode)
(add-hook 'log-view-mode-hook 'goto-address-mode)
#+END_SRC

* Counsel
This would be good to setup
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t)
#+END_SRC

* Ivy
Hate to see it, but I should use it!
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :config
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) "))
#+END_SRC

* Version Control
** VC Mode
*** Autofill When Editing Commit Message
Fill to 70 characters instead of the normal 80 to keep commit messages
clean.
#+BEGIN_SRC emacs-lisp
(add-hook 'log-edit-mode-hook 'auto-fill-mode)
(add-hook 'log-edit-mode-hook 'matiash-set-fill-column-70)
#+END_SRC

* Mail
I'm going to try using email in Emacs again - I think it will make
sifting through it much faster.
#+BEGIN_SRC emacs-lisp
(defun matiash-notmuch-remove-inbox-tag () ""
       (interactive)
       (notmuch-search-remove-tag '("-inbox")))
(use-package notmuch
  :ensure t
  :config
  (setq notmuch-fcc-dirs "Sent")
  (setq notmuch-show-logo nil)
  (setq notmuch-message-queued-tag-changes
        `((,(concat "from:" matiash-gmail-address) "+sent")))
  (setq notmuch-message-replied-tags '("+replied" "+sent"))
  (define-key notmuch-search-mode-map (kbd "i") 'matiash-notmuch-remove-inbox-tag))
#+END_SRC

* Misc
** Fill Column
Now set to 80 since that's what most people allow on lines
#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
#+END_SRC

** Narrow Region
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
#+END_SRC

** Prompt Change
Turn all prompts from yes-or-no to y-or-n
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Kill Emacs With Prompt
Prevents from closing Emacs accidentally.
#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

** Ignore Bell
#+BEGIN_SRC emacs-lisp   
(setq ring-bell-function 'ignore)
#+END_SRC

** Indentation
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

** F
Looks like Emacs wasn't loading the f package before, so I'll do this
now:
#+BEGIN_SRC emacs-lisp
(use-package f
  :ensure t)
#+END_SRC

** Isearch Forward to Match Beginning
It's annoying to not have the point go to the beginning of the
match. This lambda function will do just that:
#+BEGIN_SRC emacs-lisp
(add-hook 'isearch-mode-end-hook (lambda () (if (> (point) isearch-other-end) (goto-char isearch-other-end))))
#+END_SRC

** Save using f13
   This is a customization specific for Mac. I can rebind a key that
   osX can't understand to f13 using Karabiner, and then map f13 to
   save in Emacs.
   #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "<f13>") 'save-buffer)
   #+END_SRC

** Save File Path to Kill Ring

   #+BEGIN_SRC emacs-lisp
   (defun kill-file-path ()
     (interactive)
     (let ((file-path (buffer-file-name)))
       (kill-new file-path)))
   (global-set-key (kbd "C-x M-f") 'kill-file-path)
   #+END_SRC

** Save Buffer Name to Kill Ring
#+BEGIN_SRC emacs-lisp
(defun matiash-kill-buffer-name ()
  (interactive)
  (kill-new (buffer-name)))
(global-set-key (kbd "C-x M-b") 'matiash-kill-buffer-name)
#+END_SRC

** hs-minor-mode shortcuts
I'm really starting to think that to read code you need to hide
everything else except what you're interested in. Also, reading code
is easier when you can select the level to which you want to
read. That means being able to show or hide blocks of code is very
important.
#+BEGIN_SRC emacs-lisp
(defun matiash-toggle-block-hiding (arg)
  "If ARG is 1, toggle the showing of the block associated with point.
If ARG is > 1, toggles the hiding of a level of blocks, with
respect to the buffer as a whole. Shows all blocks when ARG is
0."
  (interactive "p")
  (message "arg is %s" arg)
  (cond
   ((> arg 1)
    (save-excursion
      (beginning-of-buffer)
      (hs-hide-level arg)))
   ((= arg 1)
    (hs-toggle-hiding))
   ((= arg 0)
    (hs-show-all))
   ((< arg 0)
    (error "Error: Negative arguments not supported"))))
(global-set-key (kbd "C-c TAB") 'matiash-toggle-block-hiding)
#+END_SRC

** Comment with C-;
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-;") 'comment-line)
#+END_SRC

** Toggle Line Spacing
I'm starting to find it hard to read lines when they're squished
together. I'm creating this line spacing function to see if adding
line spacing helps.
#+BEGIN_SRC emacs-lisp
(defun matiash-toggle-line-spacing ()
  "Toggle adding space between lines"
  (interactive)
  (if (null line-spacing)
      (setq-default line-spacing 0.5)
    (setq-default line-spacing nil)))
(global-set-key (kbd "<f12>") 'matiash-toggle-line-spacing)
  #+END_SRC

** Move Point to Help
I like having the point in the Help buffer when I open it up.
#+BEGIN_SRC emacs-lisp
(setq help-window-select t)
#+END_SRC

** Make C-w and M-w delete chars
I'm noticing that backspace is pretty hard to reach from the home
row. I know I removed a previous key-binding before, but now I'm going
to try something that's easier to reach: =C-w= and =M-w= (assuming the
region isn't active).
#+BEGIN_SRC emacs-lisp
(defun matiash-c-w-dwim (beg end &optional region arg)
  "Kills region if region is active, otherwise deletes char."
  (interactive (list (mark) (point) 'region (prefix-numeric-value current-prefix-arg)))
  (if (region-active-p)
      (kill-region beg end region)
    (backward-delete-char arg)))
(global-set-key (kbd "C-w") 'matiash-c-w-dwim)

(defun matiash-m-w-dwim (beg end &optional region)
  "Copies the region if region is active, otherwise deletes words."
  (interactive (list (mark) (point) (prefix-numeric-value current-prefix-arg)))
  (if (region-active-p)
      (kill-ring-save beg end region)
    (backward-kill-word region)))
(global-set-key (kbd "M-w") 'matiash-m-w-dwim)
#+END_SRC

** Measuring Time
I'm trying to find ways to measure the amount of time I spend doing
something, particularly for work.  I'm going to start generally and try
to measure the amount of time I work every day.  For this I'll use the
=timeclock= functions, with some configuration
*** Don't Aggregate Unworked Time
#+BEGIN_SRC emacs-lisp
(setq timeclock-relative nil)
#+END_SRC
** LSP for Java
   I'm experimenting with LSP for Java. So far I have the minimum
   needed to set it up. Commenting for now so it's not automatically
   loaded.
   #+BEGIN_SRC emacs-lisp
;;(use-package lsp-java)                  ;need
;;(add-hook 'java-mode-hook #'lsp)        ;need
;;(use-package company)                   ;really handy, I think you need
;;(use-package yasnippet)                 ;also think you need
;;(use-package lsp-ui)                    ;don't need, but useful
;;(use-package projectile)                ;don't think you need, but also seems useful
;;(global-set-key (kbd "C-c `") 'lsp-execute-code-action) ; needed to make things run smoothly
;; also use flycheck with flycheck-list-errors
;; Also try this out to get completion within lsp
;; (use-package ido-completing-read+
;;   :config
;;   (ido-ubiquitous-mode))
   #+END_SRC
